local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Hex HUB | Premium ERLC Script",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Hex HUB",
   LoadingSubtitle = "by HexBerat",
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Hex HUB"
   },

   Discord = {
      Enabled = true, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "https://discord.gg/ZDJcvbHwDC", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "Hex HUB | Key",
      Subtitle = "https://discord.gg/ZDJcvbHwDC",
      Note = "Join Server Get Script Key", -- Use this to tell the user how to get a key
      FileName = "Hex HUB | Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = true, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"https://pastebin.com/raw/m6iqd2dg"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local MainTab = Window:CreateTab(" ðŸš— Vehicle ðŸš—", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Main")

Rayfield:Notify({
   Title = "You Executed The Script",
   Content = "Hex HUB | GUÄ°",
   Duration = 5,
   Image = nil,
   Actions = { -- Notification Buttons
    Ignore = {
        Name = "Okay!",
        Callback = function()
        print("The user Tapped Okay!")
     end
   },
},
})



local Section = MainTab:CreateSection("Acceleration")




local vMult = 0.025
local accEnabled = false
local UserInputService = game:GetService("UserInputService")
local isAccelerating = false -- Track if "W" is pressed

local Toggle = MainTab:CreateToggle({
   Name = "Acceleration Enabled",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       accEnabled = value
   end,
})

local Slider = MainTab:CreateSlider({
   Name = "Speed Multiplier",
   Range = {0, 50},
   Increment = 1,
   Suffix = "Multiplier",
   CurrentValue = 25,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       vMult = value / 1000  -- Update velocity multiplier
   end,
})

-- Input handling for acceleration
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.W then
        isAccelerating = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then
        isAccelerating = false
    end
                end)

-- Connect to RunService for acceleration logic
game:GetService("RunService").Stepped:Connect(function()
    if accEnabled and isAccelerating then
        local player = game.Players.LocalPlayer
        local char = player.Character

        if char and char:IsA("Model") then
            local hum = char:FindFirstChildWhichIsA("Humanoid")
            if hum then
                local seat = hum.SeatPart
                if seat and seat:IsA("VehicleSeat") then
                    -- Modify AssemblyLinearVelocity only when "W" is held down
                    local currentVelocity = seat.AssemblyLinearVelocity
                    seat.AssemblyLinearVelocity = currentVelocity * Vector3.new(1 + vMult, 1, 1 + vMult)
                end
            end
        end
    end
end)

-- Deceleration Section
local vMult2 = 0.15
local brakeEnabled = false
local braking = false

local Section = MainTab:CreateSection("Deceleration")

local Toggle = MainTab:CreateToggle({
   Name = "Instant Brake Enable",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       brakeEnabled = value
   end,
})

local Slider = MainTab:CreateSlider({
   Name = "Instant Brake",
   Range = {0, 300},
   default = vMult2 * 1000,
   color = Color3.fromRGB(255, 255, 255),
   Increment = 1,
   Suffix = "Brake Force",
   CurrentValue = 25,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       vMult2 = value / 1000
   end,
})

-- Keybind for braking
local quickBrakeKey = Enum.KeyCode.S
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == quickBrakeKey then
        braking = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == quickBrakeKey then
        braking = false
    end
end)

-- Connect to RunService for braking logic
game:GetService("RunService").Stepped:Connect(function()
    if brakeEnabled then
        local player = game.Players.LocalPlayer
        local char = player.Character
        
        if char and char:IsA("Model") then
            local hum = char:FindFirstChildWhichIsA("Humanoid")
            if hum then
                local seat = hum.SeatPart
                if seat and seat:IsA("VehicleSeat") then
                    if braking then
                        local currentVelocity = seat.AssemblyLinearVelocity
                        seat.AssemblyLinearVelocity = currentVelocity * Vector3.new(1 - vMult2, 1, 1 - vMult2)
                    end
                end
            end
        end
    end
end)





local MainTab = Window:CreateTab("ðŸŽ Trolling ðŸŽ", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Main")





local Section = MainTab:CreateSection("First Person Fly")





local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local camera = game.Workspace.CurrentCamera

-- Define variables
local flying = false
local flyingEnabled = false
local toggleKey = Enum.KeyCode.X
local flySpeed = 50
local currentFlyCFrame -- Variable to store the current CFrame while flying

-- Function to teleport the player to a specified CFrame
local function teleportToLocation(cframe)
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        humanoidRootPart.CFrame = cframe
    end
end

-- Function to toggle flying mode
local function toggleFly()
    if flyingEnabled then
        flying = not flying
        if flying then
            -- Start flying
            if player.Character then
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    currentFlyCFrame = humanoidRootPart.CFrame -- Store the current CFrame while flying
                    humanoidRootPart.Anchored = true
                    for _, part in pairs(player.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                            part.Transparency = 1
                        end
                    end
                end
            end

            -- Lock the camera in the center
            camera.CameraType = Enum.CameraType.Scriptable
            userInputService.ModalEnabled = true

        else
            -- Stop flying
            if player.Character then
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    humanoidRootPart.Anchored = false
                    teleportToLocation(currentFlyCFrame) -- Teleport to the current CFrame
                    for _, part in pairs(player.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                            part.Transparency = 0
                        end
                    end
                end
            end

            camera.CameraType = Enum.CameraType.Custom
            camera.CameraSubject = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            userInputService.ModalEnabled = false
        end
    end
end

-- Update camera position and rotation while flying
local function onRenderStepped()
    if flying then
        local moveDirection = Vector3.new()

        -- Forward and backward movement
        if userInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + camera.CFrame.LookVector
        end
        if userInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - camera.CFrame.LookVector
        end

        -- Left and right movement
        if userInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - camera.CFrame.RightVector
        end
        if userInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + camera.CFrame.RightVector
        end

        -- Up and down movement
        if userInputService:IsKeyDown(Enum.KeyCode.E) then
            moveDirection = moveDirection + Vector3.new(0, 1, 0)
        end
        if userInputService:IsKeyDown(Enum.KeyCode.Q) then
            moveDirection = moveDirection + Vector3.new(0, -1, 0)
        end

        -- Normalize moveDirection to avoid faster diagonal movement
        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit
        end

        -- Update the camera's position
        local movement = moveDirection * flySpeed
        camera.CFrame = camera.CFrame + movement

        -- Mouse-controlled rotation
        local mouseDelta = userInputService:GetMouseDelta()
        local yaw = CFrame.Angles(0, -math.rad(mouseDelta.X * 0.1), 0)
        local pitch = CFrame.Angles(-math.rad(mouseDelta.Y * 0.1), 0, 0)

        -- Apply rotation to the camera
        camera.CFrame = camera.CFrame * yaw * pitch
    end
end

-- Function to handle mouse button events
local function onInputBegan(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rotating = true
    end
end

local function onInputEnded(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rotating = false
    end
end

-- Connect to input and render events
userInputService.InputBegan:Connect(onInputBegan)
userInputService.InputEnded:Connect(onInputEnded)
runService.RenderStepped:Connect(onRenderStepped)

local Toggle = MainTab:CreateToggle({
   Name = "Enable First Person Fly",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
        flyingEnabled = value
        if not flyingEnabled then
            flying = false
            camera.CameraType = Enum.CameraType.Custom
            camera.CameraSubject = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            userInputService.ModalEnabled = false

            if player.Character then
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    humanoidRootPart.Anchored = false
                    for _, part in pairs(player.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                            part.Transparency = 0
                        end
                    end
                end
            end
        end
    end
})

local Keybind = MainTab:CreateKeybind({
   Name = "Fly Keybind",
   CurrentKeybind = "x",
   HoldToInteract = false,
   Flag = "Keybind1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Keybind)
       toggleFly()
   end,
    changedCallback = function(key)
        toggleKey = key
        print("Changed Keybind to", key)
    end
})

local Slider = MainTab:CreateSlider({
   Name = "Adjust Fly Speed",
   Range = {1, 100},
   Increment = 1,
   Suffix = "Fly Speed",
   CurrentValue = 50,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
        flySpeed = value
        print("Fly Speed:", value)
   end,
})

-- Ensure character model is updated when respawned
player.CharacterAdded:Connect(function(character)
    character.PrimaryPart = character:WaitForChild("HumanoidRootPart")
end)

-- Fix to ensure we don't leave the HumanoidRootPart anchored
runService.RenderStepped:Connect(function()
    if flying and player.Character then
        local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            humanoidRootPart.Anchored = true
        end
    end
end)












local MainTab = Window:CreateTab("ðŸï¸ Teleportation ðŸï¸", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Main")





local Section = MainTab:CreateSection("Waypoint")

-- Define variable to store the copied CFrame
local savedCFrame = nil

-- Button to save the user's current CFrame
local Button = MainTab:CreateButton({
   Name = "Make new Waypoint",
   Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        if character and character:FindFirstChild("HumanoidRootPart") then
            savedCFrame = character.HumanoidRootPart.CFrame
            print("New waypoint saved at: " .. tostring(savedCFrame))
        else
            warn("HumanoidRootPart not found!")
        end
    end
})

-- Button to teleport to the saved CFrame
local Button = MainTab:CreateButton({
   Name = "Teleport to Waypoint",
   Callback = function()
        if savedCFrame then
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            if character and character:FindFirstChild("HumanoidRootPart") then
                -- Teleport smoothly by tweening the CFrame
                local tweenService = game:GetService("TweenService")
                local humanoidRootPart = character.HumanoidRootPart
                local teleportTween = tweenService:Create(humanoidRootPart, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = savedCFrame})

                teleportTween:Play()
                teleportTween.Completed:Wait()
                print("Teleported to waypoint.")
            else
                warn("HumanoidRootPart not found!")
            end
        else
            warn("No waypoint has been set!")
        end
    end
})













local Section = MainTab:CreateSection("Player Teleport")


local players = {}
local Select = nil

-- Function to update the players list
local function updatePlayersList()
    table.clear(players)
    for _, player in pairs(game:GetService("Players"):GetChildren()) do
        table.insert(players, player.Name)
    end
end


-- Initial population of the players list
updatePlayersList()


local Dropdown = MainTab:CreateDropdown({
   Name = "Select Player",
   Options = {"Supermario12343","KylexgffBro"},
   CurrentOption = {"Select Player"},
   MultipleOptions = true,
   Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Options)
       print("Dropdown selected:", value)  -- Print the selected value
        Select = value                       -- Store the selected value
    end
})

local Button = MainTab:CreateButton({
   Name = "Teleport!",
   Callback = function()
        if Select and game.Players:FindFirstChild(Select) then
            local targetPlayer = game.Players[Select]
            -- Wait for the target player's character to load
            if targetPlayer and targetPlayer.Character then
                local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if targetHumanoidRootPart then
                    -- Teleport the local player
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame
                else
                    print("Target player's HumanoidRootPart is not available.")
                end
            else
                print("Target player's character is not available.")
            end
        else
            print("Player not found or not selected.")
        end
    end
})

local Button = MainTab:CreateButton({
   Name = "Refresh Player List",
   Callback = function()
        updatePlayersList()  -- Update the players list
    end
})












local Section = MainTab:CreateSection("Spawn")

local Button = MainTab:CreateButton({
   Name = "Spawn",
   Callback = function()
        -- Ensure the player and their character exist
        local player = game.Players.LocalPlayer
        if player and player.Character then
            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Set the CFrame of the HumanoidRootPart to the specified coordinates
                humanoidRootPart.CFrame = CFrame.new(
                    -505.467957, 23.7107906, 652.503906, 
                    -0.99977529, 1.07727978e-08, -0.0211992487, 
                    9.80691262e-09, 1, 4.56662193e-08, 
                    0.0211992487, 4.54480578e-08, -0.99977529
                )
            end
        end
    end
})





local Section = MainTab:CreateSection("Criminal/Robbery Assitance")

local Dropdown = MainTab:CreateDropdown({
   Name = "Select Location",
   Options = {"Gun Store","Car Seller","Tool Store","Jewelry Store","Bank","Underground Bunker","Bounty Hunter"},
   CurrentOption = {"None"},
   MultipleOptions = true,
   Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Options)
        local player = game.Players.LocalPlayer
        if player and player.Character then
            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Define CFrames for each location
                local locations = {
                    None = nil,
                    ["Gun Store"] = CFrame.new(
                        -1198.71448, 23.2480125, -170.569321, 
                        0.731142402, -4.53885152e-09, -0.682224929, 
                        1.14018062e-09, 1, -5.4310787e-09, 
                        0.682224929, 3.19303206e-09, 0.731142402
                    ),
                    ["Car Seller"] = CFrame.new(
                        1624.4657, 3.82302451, -501.705902, 
                        0.408474684, -6.46358274e-08, 0.912769675, 
                        1.10165317e-08, 1, 6.5882837e-08, 
                        -0.912769675, -1.6855914e-08, 0.408474684
                    ),
                    ["Tool Store"] = CFrame.new(
                        -439.869232, 24.5106964, -715.560669, 
                        -0.865956128, 4.48093083e-08, -0.500119984, 
                        -1.10567413e-08, 1, 1.0874183e-07, 
                        0.500119984, 9.96953489e-08, -0.865956128
                    ),
                    ["Jewelry Store"] = CFrame.new(
                        -464.756714, 23.7106667, -411.026428, 
                        0.998576045, 4.38038744e-10, -0.0533464141, 
                        -2.77688805e-09, 1, -4.37685514e-08, 
                        0.0533464141, 4.38543637e-08, 0.998576045
                    ),
                    ["Bank"] = CFrame.new(
                        -1140.61011, 23.2476749, 449.233765, 
                        -0.0293217897, 1.06881526e-08, -0.999570012, 
                        5.65440361e-09, 1, 1.05268816e-08, 
                        0.999570012, -5.34330535e-09, -0.0293217897
                    ),
                    ["Underground Bunker"] = CFrame.new(
                        -1357.98584, 2.37512946, -1234.61914, 
                        -0.953902245, 5.52598145e-08, 0.300117463, 
                        4.44210784e-08, 1, -4.29380123e-08, 
                        -0.300117463, -2.76271255e-08, -0.953902245
                    ),
                    ["Bounty Hunter"] = CFrame.new(
                        2931.9292, 76.5576782, -776.82666, 
                        -0.891279995, 2.90516162e-08, -0.453453422, 
                        1.11739749e-10, 1, 6.38478497e-08, 
                        0.453453422, 5.68556402e-08, -0.891279995
                    ),
                }

                -- Get the selected location's CFrame
                local selectedCFrame = locations[value]
                
                -- Teleport the player to the selected location if CFrame is valid
                if selectedCFrame then
                    humanoidRootPart.CFrame = selectedCFrame
                end
            end
        end
    end    
})

local MainTab = Window:CreateTab("ðŸ§§ AutoFarm ðŸ§§", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Main")












-- Importing necessary services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

-- Provided CFrames for destinations
local storeCFrame = CFrame.new(
    -455.536682, 24.7214737, -687.226135, 0.876918554, 3.13342667e-08, 0.480638951, -2.77348455e-08, 1, -1.45911274e-08, -0.480638951, -5.35217148e-10, 0.876918554
)

local atmCFrames = {
    CFrame.new(-487.234985, 23.5106659, 443.568207, -0.999979198, -5.70977718e-08, -0.00645062281, -5.67480356e-08, 1, -5.44004273e-08, 0.00645062281, -5.40332366e-08, -0.999979198),
    CFrame.new(-373.058441, 23.7106667, 152.555481, -0.0523415469, 3.93065207e-08, -0.998629212, 7.02295644e-09, 1, 3.89923791e-08, 0.998629212, -4.97240826e-09, -0.0523415469),
    CFrame.new(-585.008362, 23.4106693, -407.933228, 0.999987304, 3.31979022e-09, 0.00503399037, -3.18748739e-09, 1, -2.62899285e-08, -0.00503399037, 2.62735504e-08, 0.999987304),
    CFrame.new(-967.635864, 23.704155, 830.456543, -0.997961044, -9.30583699e-09, 0.0638261139, -6.73221168e-09, 1, 4.05375218e-08, -0.0638261139, 4.00251743e-08, -0.997961044),
    CFrame.new(-1018.83417, 23.8458786, 442.709198, -0.991912425, 1.11027113e-07, 0.126924261, 1.04882979e-07, 1, -5.50910251e-08, -0.126924261, -4.13332764e-08, -0.991912425),
    CFrame.new(997.054443, 3.66067648, -24.243906, -0.996836483, -5.71199843e-09, -0.0794795305, -2.2830704e-09, 1, -4.32331468e-08, 0.0794795305, -4.29149232e-08, -0.996836483),
    CFrame.new(1116.06946, 3.66068506, 372.264221, 0.0631054267, 9.48825303e-08, -0.99800688, 3.07471781e-09, 1, 9.52664436e-08, 0.99800688, -9.08041908e-09, 0.0631054267),
    CFrame.new(2486.40308, -11.9173231, -1738.61816, 0.999716699, -6.19399954e-09, 0.0238016658, 3.82558785e-09, 1, 9.955167e-08, -0.0238016658, -9.94324125e-08, 0.999716699),
    CFrame.new(2614.15723, -11.9173908, -2099.10449, 0.999586463, -4.06346246e-08, 0.0287568029, 4.17840411e-08, 1, -3.93694037e-08, -0.0287568029, 4.05546992e-08, 0.999586463),
    CFrame.new(2562.21167, -11.917448, -2238.40405, 0.032482598, 9.06827893e-08, -0.99947232, 9.15809539e-10, 1, 9.07604303e-08, 0.99947232, -3.86346066e-09, 0.032482598)
}

-- Fixed tween time
local tweenTime = 10  -- Duration in seconds
local undergroundOffset = Vector3.new(0, -10, 0)  -- Adjust this value based on your map's height

-- Variables to manage the state
local isActive = false
local stopAtNext = false
local currentIndex = 1

-- Teleport function with tween effect
local function teleportWithTween(character, destinations, tweenTime)
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        warn("HumanoidRootPart not found in character")
        return
    end

    -- Create a coroutine to handle sequential tweening
    coroutine.wrap(function()
        while isActive do
            -- Get the current ATM CFrame
            local atmCFrame = destinations[currentIndex]

            -- Go to ATM and then return to store
            local sequence = {
                storeCFrame,  -- Go to store
                atmCFrame,    -- Go to ATM
                storeCFrame   -- Return to store
            }
            
            for _, targetCFrame in ipairs(sequence) do
                -- Define underground CFrame
                local undergroundCFrame = targetCFrame * CFrame.new(undergroundOffset)

                -- Tween to the underground position
                local tweenInfo = TweenInfo.new(
                    tweenTime,  -- Duration in seconds
                    Enum.EasingStyle.Linear,  -- Easing style
                    Enum.EasingDirection.InOut  -- Easing direction
                )

                local tweenGoal = {CFrame = undergroundCFrame}
                local tween = TweenService:Create(humanoidRootPart, tweenInfo, tweenGoal)
                tween:Play()
                tween.Completed:Wait()

                -- Tween directly to the final position
                local finalTweenGoal = {CFrame = targetCFrame}
                local finalTween = TweenService:Create(humanoidRootPart, tweenInfo, finalTweenGoal)
                finalTween:Play()
                finalTween.Completed:Wait()

                if stopAtNext then
                    stopAtNext = false
                    return  -- Exit the coroutine to stop the autofarm
                end
            end

            -- Move to the next ATM in the list
            currentIndex = (currentIndex % #destinations) + 1
        end
    end)()
end

-- Callback function for the toggle
local function onToggleActivated(isOn)
    print("Toggle State: " .. tostring(isOn))
    
    if isOn then
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        
        -- Reset state
        isActive = true
        stopAtNext = false
        currentIndex = 1
        
        -- Start the teleportation coroutine
        teleportWithTween(character, atmCFrames, tweenTime)
    else
        -- Stop the autofarm at the next destination
        stopAtNext = true
    end
end

local Toggle = MainTab:CreateToggle({
   Name = "AutoFarm",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = onToggleActivated
})












local MainTab = Window:CreateTab("ðŸŒ• Esp ðŸŒ•", nil) -- Title, Image



local Section = MainTab:CreateSection("Esps")



-- Declare a variable to track the ESP state
local isESPEnabled = false

-- Function to enable ESP
local function enableESP()
    local Holder = Instance.new("Folder", game.CoreGui)
    Holder.Name = "ESP"

    local Box = Instance.new("BoxHandleAdornment")
    Box.Name = "nilBox"
    Box.Size = Vector3.new(1, 2, 1)
    Box.Color3 = Color3.new(100 / 255, 100 / 255, 100 / 255)
    Box.Transparency = 0.7
    Box.ZIndex = 0
    Box.AlwaysOnTop = false
    Box.Visible = false

    local NameTag = Instance.new("BillboardGui")
    NameTag.Name = "nilNameTag"
    NameTag.Enabled = false
    NameTag.Size = UDim2.new(0, 200, 0, 50)
    NameTag.AlwaysOnTop = true
    NameTag.StudsOffset = Vector3.new(0, 1.8, 0)
    
    local Tag = Instance.new("TextLabel", NameTag)
    Tag.Name = "Tag"
    Tag.BackgroundTransparency = 1
    Tag.Position = UDim2.new(0, -50, 0, 0)
    Tag.Size = UDim2.new(0, 300, 0, 20)
    Tag.TextSize = 20
    Tag.TextColor3 = Color3.new(100 / 255, 100 / 255, 100 / 255)
    Tag.TextStrokeColor3 = Color3.new(0 / 255, 0 / 255, 0 / 255)
    Tag.TextStrokeTransparency = 0.4
    Tag.Text = ""
    Tag.Font = Enum.Font.SourceSansBold
    Tag.TextScaled = false

    local function LoadCharacter(v)
        repeat wait() until v.Character ~= nil
        v.Character:WaitForChild("Humanoid")
        
        local vHolder = Holder:FindFirstChild(v.Name) or Instance.new("Folder", Holder)
        vHolder.Name = v.Name
        vHolder:ClearAllChildren()

        local b = Box:Clone()
        b.Name = v.Name .. "Box"
        b.Adornee = v.Character
        b.Parent = vHolder
        
        local t = NameTag:Clone()
        t.Name = v.Name .. "NameTag"
        t.Enabled = true
        t.Parent = vHolder
        t.Adornee = v.Character:WaitForChild("Head", 5)

        if not t.Adornee then
            return UnloadCharacter(v)
        end

        t.Tag.Text = v.Name
        b.Color3 = Color3.new(v.TeamColor.r, v.TeamColor.g, v.TeamColor.b)
        t.Tag.TextColor3 = Color3.new(v.TeamColor.r, v.TeamColor.g, v.TeamColor.b)

        local UpdateNameTag = function()
            if pcall(function()
                v.Character.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
            end) then
                t.Tag.Text = v.Name  -- Update the name each time
            end
        end
        
        UpdateNameTag()
        v.Character.Humanoid.Changed:Connect(UpdateNameTag)
    end

    local function UnloadCharacter(v)
        local vHolder = Holder:FindFirstChild(v.Name)
        if vHolder then
            vHolder:ClearAllChildren()
        end
    end

    local function LoadPlayer(v)
        local vHolder = Instance.new("Folder", Holder)
        vHolder.Name = v.Name
        v.CharacterAdded:Connect(function()
            pcall(LoadCharacter, v)
        end)
        v.CharacterRemoving:Connect(function()
            pcall(UnloadCharacter, v)
        end)
        v.Changed:Connect(function(prop)
            if prop == "TeamColor" then
                UnloadCharacter(v)
                wait()
                LoadCharacter(v)
            end
        end)
        LoadCharacter(v)
    end

    local function UnloadPlayer(v)
        UnloadCharacter(v)
        local vHolder = Holder:FindFirstChild(v.Name)
        if vHolder then
            vHolder:Destroy()
        end
    end

    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
        spawn(function() pcall(LoadPlayer, v) end)
    end

    game:GetService("Players").PlayerAdded:Connect(function(v)
        pcall(LoadPlayer, v)
    end)

    game:GetService("Players").PlayerRemoving:Connect(function(v)
        pcall(UnloadPlayer, v)
    end)

    game:GetService("Players").LocalPlayer.NameDisplayDistance = 0
end

-- Function to disable ESP
local function disableESP()
    local holder = game.CoreGui:FindFirstChild("ESP")
    if holder then
        holder:Destroy()
    end
end

local Toggle = MainTab:CreateToggle({
   Name = "Name Esp",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
        isESPEnabled = value
        if isESPEnabled then
            enableESP()
        else
            disableESP()
        end
    end,
})












-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Configuration for ESP
local config = {
    ESP = {
        Box = {
            Box = true,
            TeamCheck = false,
            BoxColor = Color3.fromRGB(0, 0, 0),
            TeamColor = true
        }
    }
}

-- Toggle state variable
local isToggleOn = false

-- Create and update ESP boxes
local function createBoxESP(playerCharacter)
    -- Check if the character is not the local player
    if playerCharacter == Players.LocalPlayer then return end

    -- Create ESP GUI elements
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Parent = playerCharacter.Character:FindFirstChild("HumanoidRootPart") or playerCharacter.Character
    billboardGui.Name = playerCharacter.Name .. "_BoxESP"
    billboardGui.AlwaysOnTop = true
    billboardGui.Size = UDim2.new(4, 0, 5.4, 0)
    billboardGui.ClipsDescendants = false
    billboardGui.Enabled = isToggleOn

    local frame = Instance.new("Frame", billboardGui)
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BorderSizePixel = 1
    frame.BackgroundTransparency = 1

    local topFrame = Instance.new("Frame", frame)
    topFrame.BorderSizePixel = 1
    topFrame.Size = UDim2.new(1, 0, 0, 2)
    topFrame.Position = UDim2.new(0, 0, 0, 0)

    local bottomFrame = Instance.new("Frame", frame)
    bottomFrame.BorderSizePixel = 1
    bottomFrame.Size = UDim2.new(1, 0, 0, 2)
    bottomFrame.Position = UDim2.new(0, 0, 1, -2)

    local leftFrame = Instance.new("Frame", frame)
    leftFrame.BorderSizePixel = 1
    leftFrame.Size = UDim2.new(0, 2, 1, 0)
    leftFrame.Position = UDim2.new(0, 0, 0, 0)

    local rightFrame = Instance.new("Frame", frame)
    rightFrame.BorderSizePixel = 1
    rightFrame.Size = UDim2.new(0, 2, 1, 0)
    rightFrame.Position = UDim2.new(1, -2, 0, 0)

    -- Coroutine to update ESP boxes
    coroutine.wrap(function()
        while wait(0.1) do
            if playerCharacter and playerCharacter.Character and playerCharacter.Character:FindFirstChild("Humanoid") then
                local humanoid = playerCharacter.Character.Humanoid
                if humanoid.Health > 0 then
                    billboardGui.Adornee = playerCharacter.Character.HumanoidRootPart

                    -- Update visibility based on toggle and team check
                    if config.ESP.Box.Box then
                        frame.Visible = true
                    else
                        frame.Visible = false
                    end

                    if config.ESP.Box.TeamCheck and (playerCharacter.TeamColor == Players.LocalPlayer.TeamColor) then
                        billboardGui.Enabled = false
                    else
                        billboardGui.Enabled = isToggleOn
                    end

                    -- Update color based on team or default
                    local color = config.ESP.Box.BoxColor
                    if config.ESP.Box.TeamColor then
                        color = playerCharacter.TeamColor.Color
                    end

                    topFrame.BackgroundColor3 = color
                    bottomFrame.BackgroundColor3 = color
                    leftFrame.BackgroundColor3 = color
                    rightFrame.BackgroundColor3 = color
                    frame.BackgroundColor3 = color
                else
                    billboardGui.Enabled = false
                    billboardGui.Adornee = nil
                    frame.Visible = false
                end
            else
                billboardGui.Enabled = false
                billboardGui.Adornee = nil
                frame.Visible = false
            end

            if not Players:FindFirstChild(playerCharacter.Name) then
                billboardGui:Destroy()
                return
            end
        end
    end)()
end

local Toggle = MainTab:CreateToggle({
   Name = "Box Esp",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
         isToggleOn = value
        -- Update all existing ESPs based on the new toggle state
        for _, player in ipairs(Players:GetPlayers()) do
            if player.Character and player ~= Players.LocalPlayer then
                local billboardGui = player.Character:FindFirstChild(player.Name .. "_BoxESP")
                if billboardGui then
                    billboardGui.Enabled = isToggleOn and (not config.ESP.Box.TeamCheck or player.TeamColor ~= Players.LocalPlayer.TeamColor)
                    billboardGui:FindFirstChild("Frame").Visible = isToggleOn
                end
            end
        end
    end
})

-- Connect player events
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        createBoxESP(player)
    end)
end)

-- Handle existing players
for _, player in ipairs(Players:GetPlayers()) do
    if player.Character and player ~= Players.LocalPlayer then
        createBoxESP(player)
    end
end












-- Dependencies
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- Get the local player and the camera
local localPlayer = Players.LocalPlayer
local currentCamera = Workspace.CurrentCamera

-- Variable to keep track of Distance ESP toggle state
local distanceESPEnabled = false

-- Container for BillboardGui objects
local distanceDisplays = {}

-- Function to calculate distance from the camera to a part
local function getDistanceFromCamera(part)
    return (part.Position - currentCamera.CFrame.Position).Magnitude
end

-- Function to create and display the BillboardGui
local function createDistanceDisplay(player)
    local character = player.Character
    if not character then return end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    -- Create the BillboardGui
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = player.Name .. "_DistanceDisplay"
    billboardGui.Parent = humanoidRootPart
    billboardGui.Size = UDim2.new(0, 60, 0, 50) -- Size of the BillboardGui
    billboardGui.Adornee = humanoidRootPart
    billboardGui.AlwaysOnTop = true
    billboardGui.StudsOffset = Vector3.new(3, 0, 0) -- Position to the right of the player
    billboardGui.ClipsDescendants = true

    -- Create the TextLabel
    local textLabel = Instance.new("TextLabel")
    textLabel.Parent = billboardGui
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextScaled = true
    textLabel.Text = "Distance: 0 "

    -- Update the distance display
    local function updateDistance()
        local distance = math.floor(getDistanceFromCamera(humanoidRootPart))
        textLabel.Text = string.format("Distance: %d ", distance)
    end

    -- Connect to RenderStepped to update the distance
    local renderConnection
    renderConnection = RunService.RenderStepped:Connect(function()
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            billboardGui:Destroy()
            if renderConnection then
                renderConnection:Disconnect()
            end
        else
            updateDistance()
        end
    end)

    -- Store the billboardGui in the distanceDisplays table
    distanceDisplays[player] = billboardGui
end

-- Function to handle player addition
local function onPlayerAdded(player)
    if distanceESPEnabled and player.Character then
        createDistanceDisplay(player)
    end
    player.CharacterAdded:Connect(function()
        if distanceESPEnabled then
            createDistanceDisplay(player)
        end
    end)
end

-- Function to handle player removal
local function onPlayerRemoving(player)
    if distanceDisplays[player] then
        distanceDisplays[player]:Destroy()
        distanceDisplays[player] = nil
    end
end

-- Toggle functionality
local function toggleDistanceESP(shouldEnable)
    if shouldEnable == distanceESPEnabled then return end

    -- Turn off Distance ESP
    if not shouldEnable then
        for _, display in pairs(distanceDisplays) do
            display:Destroy()
        end
        distanceDisplays = {}
        distanceESPEnabled = false
    else
        -- Turn on Distance ESP
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= localPlayer then
                local character = player.Character
                if character then
                    createDistanceDisplay(player)
                end
            end
        end

        -- Start listening for new players
        Players.PlayerAdded:Connect(onPlayerAdded)
        Players.PlayerRemoving:Connect(onPlayerRemoving)

        distanceESPEnabled = true
    end
end

local Toggle = MainTab:CreateToggle({
   Name = "Distance Esp",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       toggleDistanceESP(value)
    end
})












local MainTab = Window:CreateTab("â­ Aimbot â­", nil) -- Title, Image

local Section = MainTab:CreateSection("Aimbot Settings")





local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local CurrentTarget = nil
local isAiming = false

_G.AimbotEnabled = false
_G.TeamCheck = false
_G.AimPart = "Head"
_G.Sensitivity = 0
local fov = 80
local fovColor = Color3.fromRGB(255, 0, 0)
local fovEnabled = false
local fovPosition = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

local FOVring = Drawing.new("Circle")
FOVring.Visible = false
FOVring.Thickness = 1.5
FOVring.Radius = fov
FOVring.Transparency = 0.5
FOVring.Color = fovColor

local function GetClosestPlayer()
    local MaximumDistance = 80
    local Target = nil

    for _, v in next, Players:GetPlayers() do
        if v.Name ~= LocalPlayer.Name then
            if _G.TeamCheck and v.Team == LocalPlayer.Team then
                continue
            end
            if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and 
               v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then

                local ScreenPoint = Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
                local VectorDistance = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                
                if VectorDistance < MaximumDistance then
                    Target = v
                    break
                end
            end
        end
    end

    return Target
end

UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 and _G.AimbotEnabled then
        isAiming = true
        CurrentTarget = GetClosestPlayer()
    elseif Input.UserInputType == Enum.UserInputType.MouseButton1 and fovEnabled then
        UserInputService.InputChanged:Connect(function(moveInput)
            if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                fovPosition = UserInputService:GetMouseLocation()
            end
        end)
    end
end)

UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        isAiming = false
        CurrentTarget = nil
    end
end)

RunService.RenderStepped:Connect(function()
    if CurrentTarget and _G.AimbotEnabled and isAiming then
        local aimPosition
        if _G.AimPart == "Torso" then
            aimPosition = CurrentTarget.Character.HumanoidRootPart.Position
        else
            aimPosition = CurrentTarget.Character[_G.AimPart].Position
        end

        TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), 
        {CFrame = CFrame.new(Camera.CFrame.Position, aimPosition)}):Play()
    end

    if fovEnabled then
        FOVring.Position = fovPosition
        FOVring.Visible = true
        FOVring.Radius = fov
        FOVring.Color = fovColor
        FOVring.Transparency = 0.5
    else
        FOVring.Visible = false
    end
end)

local Toggle = MainTab:CreateToggle({
   Name = "Enable Aimbot",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       _G.AimbotEnabled = value
    end
})

local Dropdown = MainTab:CreateDropdown({
   Name = "Aim Part",
   Options = {"Head","Torso"},
   CurrentOption = {"None"},
   MultipleOptions = false,
   Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Options)
       _G.AimPart = value
    end
})

local Section = MainTab:CreateSection("FOV Circle")

local Toggle = MainTab:CreateToggle({
   Name = "Enable FOV Circle",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       fovEnabled = value
    end
})

local ColorPicker = MainTab:CreateColorPicker({
    Name = "Pick a Color",
    Color = Color3.fromRGB(255,255,255),
    Flag = "ColorPicker1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        fovColor = color
        FOVring.Color = fovColor
    end
})
